{"version":3,"sources":["/Users/rasmus/src2/jo/src/jo/transformers/modules.js","/Users/rasmus/src2/jo/src/jo/transformers/file-local-vars.js","/Users/rasmus/src2/jo/src/jo/transformers/class-hierarcy.js"],"names":[],"mappings":"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","file":"out","sourcesContent":["// interface Import {\n//   ref:string                      // e.g. `import \"lol/foo\"` => 'lol/foo'\n//   file:SrcFile\n//   moduleID:AST.Identifier         // e.g. `import foo from \"lol/foo\"` => 'foo'\n//   members:[{asID: AST.Identifier, srcID:AST.Identifier}, ...]\n//      e.g. `import {Foo as bar} from \"foo\"` => {bar:'Foo'}\n//   node:ASTNode                    // the import node\n// }\nimport {repr, JSIdentifier, SrcError, SrcLocation} from '../util'\nimport {types as t} from 'npmjs.com/babel'\nvar __DEV__ = true; // FIXME remove when we build ourselves\n\nfunction ImportError(file, node, message, fixSuggestion, related) {\n  return SrcError('ImportError', SrcLocation(node, file), message, fixSuggestion, related);\n}\n\n\nvar implicitExportNameRe = /^[A-Z]/u;\n  // TODO: Add all upper-case Unicode letters to the regex, e.g. \\uXXXX-\\uXXXX ...\n\nfunction isImplicitExportName(name) {\n  return name.match(implicitExportNameRe) //&& (name[0] === name[0].toUpperCase());\n}\n\n\nexport var ModuleTransformer = {\n\n  ImportDeclaration(node, parent, scope, file) {\n    if (node.isType) return;\n\n    if (node.range && node.range[0] > file.joFirstNonImportOffset) {\n      throw ImportError(file.jofile, node, 'unexpected import below non-import statement');\n    }\n\n    // Note: Imports are only at \"program\" level, enforced by the parser,\n    // so no need to check parent.type==='Program'.\n\n    if (node.source.value.substr(0,14) === 'babel-runtime/') {\n      //console.log('runtime-helper', repr(node,3));\n      node.jo_isRuntimeHelper = true;\n    } else {\n      if (node.specifiers.length) {\n        let hasDefault = false;\n        for (let i = 0, L = node.specifiers.length; i !== L; ++i) {\n          let spec = node.specifiers[i];\n          let origName;\n          if (spec.name) {\n            // x as y\n            origName = spec.name.name;\n            spec.name = file.joLocalizeIdentifier(spec.name.name)\n          } else {\n            origName = spec.id.name;\n            spec.id._origName = spec.id.name;\n            spec.name = file.joLocalizeIdentifier(spec.id.name)\n          }\n          if (spec.type === 'ImportBatchSpecifier') {\n            let rtHelperNode = {\n              _blockHoist: 3,\n              type: 'ImportDeclaration',\n              specifiers: [\n                { type: 'ImportSpecifier',\n                  id: { type: 'Identifier', name: 'default' },\n                  name: { type: 'Identifier', name: '_interopRequireWildcard' },\n                }\n              ],\n              source: { type: 'Literal', value: 'babel-runtime/helpers/interop-require-wildcard' },\n              jo_isRuntimeHelper: true,\n            };\n            // file.scope.registerDeclaration(rtHelperNode);\n            file.scope.registerBinding(\"module\", rtHelperNode);\n            file.joImports.push(rtHelperNode);\n          }\n          spec.name._origName = origName; // because scope.rename() later on\n          if (spec.default) {\n            hasDefault = true;\n          }\n        }\n        // if (!hasDefault) {\n        //   console.log('!hasDefault', node.specifiers)\n        //   let anonID = file.joGenAnonID();\n        //   node.specifiers.splice(0,0, t.importSpecifier(anonID, null) );\n        //   // node.specifiers[0].default = true;\n        // }\n      } else {\n        // TODO: `import \"bar/jo-foo.git\"` -> `import foo from \"bar/jo-foo.git\"`\n        let name = JSIdentifier.fromString(node.source.value);\n        if (!name || !JSIdentifier.isValid(name)) {\n          throw ImportError(file.jofile, node.source, 'failed to infer module identifier');\n        }\n        let id = file.joLocalizeIdentifier(name)\n        node.specifiers = [ t.importSpecifier(t.identifier(\"default\"), id) ];\n        node.specifiers[0].default = true;\n      }\n    }\n\n    // Extract imports -- will eventually be hoisted to package header\n    file.joImports.push(node);\n    try {\n      file.scope.registerBinding(\"module\", node);\n    } catch (e) {\n      // Most likely duplicate\n    }\n    return [];\n  },\n\n\n  VariableDeclaration(node, parent, scope, file) {\n    // Export UpperCase vars at the module level.\n    // At this point in transformations, const, let and class have been\n    // converted to var, so this catches all but function.\n    if (parent.type === 'Program') {\n      if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n        file.joFirstNonImportOffset = node.range[0];\n      }\n      var i, id, decls = node.declarations, exportDecls = [];\n      for (i = 0; i !== decls.length; ++i) {\n        id = decls[i].id;\n        if (isImplicitExportName(id.name)) {\n          // console.log('export var', repr(decls[i], 2))\n          file.joRegisterExport(id.name, decls[i].id, /*isImplicitExport=*/true);\n        }\n      }\n    }\n  },\n\n\n  FunctionDeclaration(node, parent, scope, file) {\n    // Export UpperCase functions at the module level.\n    if (parent.type === 'Program') {\n      if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n        file.joFirstNonImportOffset = node.range[0];\n      }\n      if (isImplicitExportName(node.id.name)) {\n        // console.log('export function', repr(node, 2))\n        file.joRegisterExport(node.id.name, node.id, /*isImplicitExport=*/true);\n      }\n    }\n  },\n\n\n  ExportDeclaration(node, parent, scope, file) {\n    // Note: Always at program-level.\n\n    // Note: we don't see export statements until they have been processed by\n    // some other part of Babel, which hoists them to the top, meaning that\n    // if we set file.joHasPassedImports=true here, it will be set _before_\n    // the first line. I.e. in this program:\n    //   import 'a'\n    //   export function f() {}\n    // Babel will rewrite the AST to:\n    //   export {f as f}\n    //   import 'a'\n    //   function f() {}\n    // Meaning we will visit `export {f as f}` before we visit `import 'a'`.\n\n    if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n      file.joFirstNonImportOffset = node.range[0];\n    }\n\n    if (node.declaration) {\n      if (node.default) {\n        // export default ...\n        file.joRegisterExport('default', node.declaration);\n      } else {\n        if (__DEV__) { t.assertVariableDeclaration(node.declaration); }\n        let decl = node.declaration.declarations[0];\n        if (__DEV__) { t.assertVariableDeclarator(decl); }\n        file.joRegisterExport(decl.id.name, decl.id);\n        return node.declaration;\n      }\n    } else {\n      // node.specifiers:ExportSpecifier[]\n      // console.log('export', repr(node, 3))\n      node.specifiers.forEach((spec) => {\n        file.joRegisterExport(spec.name ? spec.name.name : spec.id.name, spec.id);\n      })\n    }\n    return [];\n  },\n\n\n  // post(file) {\n  //   // Append export statements to the end.\n  //   if (file.joIsLastFile) {\n  //     //file.ast.program.body\n  //     console.log(repr(file.ast));\n  //   }\n  // }\n\n}\n","import {SrcLocation, SrcError} from '../util'\nimport {types as t} from 'npmjs.com/babel'\n\n\nfunction ReferenceError(file, node, message, related) {\n  return SrcError('ReferenceError', SrcLocation(node, file), message, null, related);\n}\n\n\nexport var FileLocalVarsTransformer = {\n\n  IfStatement(node, parent, scope, file) {\n    var test = node.test;\n    if (test.type === 'Identifier' && test.name === '__DEV__' && !scope.getBindingInfo(test.name)) {\n      if (node.consequent.type === 'BlockStatement' && !node.consequent._letReferences) {\n        return node.consequent.body;\n      }\n      return node.consequent;\n    }\n  },\n\n  Identifier(node, parent, scope, file) {\n    if (node.name === '__DEV__' && !scope.getBindingInfo(node.name)) {\n      return t.literal(file.joTarget.isDevMode);\n    }\n  },\n\n  FunctionDeclaration(node, parent, scope, file) {\n    if (node.id &&\n        node.id.type === 'Identifier' &&\n        node.id.name === 'init' &&\n        parent.type === 'Program')\n    {\n      node.id = file.joLocalizeIdentifier(node.id.name);\n      file.jofile.initFuncName = node.id.name;\n    }\n  },\n\n  // ObjectExpression(node, parent, scope, file) {\n  //   if (file.jofile.name === 'primate.js') {\n  //     console.log('ObjectExpression:', repr(node,0))\n  //   }\n  // },\n\n  post(file) {\n    // Rename remapped identifiers in this file\n    Object.keys(file.joRemappedIdentifiers).forEach((oldName) => {\n      file.scope.rename(oldName, file.joRemappedIdentifiers[oldName]);\n    });\n\n    // dumpScopeBindings(file.scope);\n\n    var undefinedSymbolResolvers = {\n\n      React: (node, parent, scope) => {\n        // Add `import React from \"react\"`\n        file.joAddImplicitImport('react', {'default':'React'}, node);\n        return true;\n      },\n\n      ReactComponent: (node, parent, scope) => {\n        // Add `import {Component as ReactComponent} from \"react\"`\n        file.joAddImplicitImport('react', {'Component':'ReactComponent'}, node);\n        return true;\n      },\n\n    };\n\n    // Attempt to automatically resolve any undefined references, like \"React\".\n    var verifyReference = (name, node, parent, scope) => {\n      if (!(node.name in file.joTarget.globals)) {\n        var info = scope.getBindingInfo(node.name);\n        if (!info) {\n          let resolver = undefinedSymbolResolvers[node.name];\n          if (!resolver || !resolver(node, parent, scope)) {\n            if (!file.jofile.unresolvedIDs) { file.jofile.unresolvedIDs = {}; }\n            if (!file.jofile.unresolvedIDs[node.name]) {\n              file.jofile.unresolvedIDs[node.name] = {node:node};\n            }\n            if (file.jofile.superclassReferences) {\n              let superclassRef = file.jofile.superclassReferences[node.name];\n              if (superclassRef) {\n                if (!file.jofile.unresolvedSuperclassIDs) {\n                  file.jofile.unresolvedSuperclassIDs = {};\n                }\n                file.jofile.unresolvedSuperclassIDs[node.name] = superclassRef;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    file.scope.traverse(file.scope.block, {\n      enter: function enter(node, parent, scope) {\n        if (parent.type === 'BreakStatement') {\n          // BUG: Can't handle \"break to label\" reference checks. This means that\n          //      \"break foo;\" will not generate any errors, even when there's no\n          //      label called \"foo\".\n          return;\n        }\n        if (t.isReferencedIdentifier(node, parent)) {\n          verifyReference(node.name, node, parent, scope);\n        }\n      }\n    });\n\n    // Special code for \"exports default { ... }\"\n    if (file.joPkg.exports['default']) {\n      file.scope.traverse(file.joPkg.exports['default'].node, {\n        enter: function enter(node, parent, scope) {\n          if (t.isReferencedIdentifier(node, parent)) {\n            let name = node.name;\n            if (!(name in file.joTarget.globals) && !(name in file.scope.globals)) {\n              var info = scope.getBindingInfo(name);\n              if (!info) {\n                let remapped = file.joRemappedIdentifiers[name];\n                if (remapped) {\n                  node.name = remapped;\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n\n    // A map of any identifiers defined at the program-level of this file\n    // console.log('file.scope.bindings:', repr(file.scope.bindings,2));\n    Object.keys(file.scope.bindings).forEach(name => {\n      var binding = file.scope.bindings[name];\n      if (binding &&\n          (binding.kind === 'var' ||\n           binding.kind === 'let' ||\n           binding.kind === 'const' ||\n           binding.kind === 'hoisted') )\n      {\n\n        if (!file.jofile.definedIDs) {\n          file.jofile.definedIDs = {};\n        }\n        if (!file.jofile.definedIDs[name]) {\n          file.jofile.definedIDs[name] = binding;\n        }\n\n        // Check for duplicate ID\n        if (!file.joPkg.definedIDs) {\n          file.joPkg.definedIDs = {};\n        } else if(file.joPkg.definedIDs[name]) {\n          let existingDecl = file.joPkg.definedIDs[name];\n\n          let bindingKind = binding.kind;\n          let otherBindingKind = existingDecl.binding.kind;\n          let node = binding.node;\n          let otherNode = existingDecl.binding.node;\n\n          if (bindingKind === 'hoisted') {\n            bindingKind = 'function';\n            node = node.id;\n          }\n\n          if (otherBindingKind === 'hoisted') {\n            otherBindingKind = 'function';\n            otherNode = otherNode.id;\n          }\n\n          throw ReferenceError(\n            file.jofile,\n            node,\n            `duplicate identifier in ${bindingKind} declaration`,\n            [{ message: `${otherBindingKind} declared here`,\n              srcloc: SrcLocation(otherNode, existingDecl.file)\n            }]\n          );\n        }\n\n        // Register ID\n        file.joPkg.definedIDs[name] = {binding:binding, file:file.jofile};\n        \n        // Is main() function?\n        if (name === 'main' && binding.node.type === 'FunctionDeclaration') {\n          // Note: as main is included in definedIDs we already check for duplicate declarations,\n          // so no need to check for duplicate mainFunc here.\n          file.joPkg.mainFunc = {node: binding.node, file: file.jofile};\n        }\n\n      } //else console.log('other binding', binding ? binding.kind : binding);\n    });\n  }\n\n}\n\n\n// function dumpScopeBindings(scope, depth=0) {\n//   let indent =\n//     '                                                                      '.substr(0,depth*4);\n//   for (var k in scope.bindings) {\n//     console.log(indent+k, '=>', repr(scope.bindings[k],0));\n//   }\n//   if (depth !== -1 && scope.parent) {\n//     console.log(indent+'.parent:');\n//     dumpScopeBindings(scope.parent, depth+1);\n//   }\n// }\n","export var ClassHierarchyTransformer = {\n\n  ClassDeclaration(node, parent, scope, file) {\n    if (!file.jofile.classDeclaration) { file.jofile.classDeclaration = {}; }\n    file.jofile.classDeclaration[node.id.name] = node.superClass || null;\n\n    if (node.superClass) {\n      // console.log('class', node.id.name, 'extends', node.superClass.name);\n      if (!file.jofile.superclassReferences) { file.jofile.superclassReferences = {}; }\n      file.jofile.superclassReferences[node.superClass.name] = node;\n    }\n  }\n\n}\n"]}