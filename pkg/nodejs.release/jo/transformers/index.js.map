{"version":3,"sources":["/Users/rasmus/src2/jo/src/jo/transformers/modules.js","/Users/rasmus/src2/jo/src/jo/transformers/file-local-vars.js","/Users/rasmus/src2/jo/src/jo/transformers/class-hierarcy.js"],"names":[],"mappings":"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","file":"out","sourcesContent":["// interface Import {\n//   ref:string                      // e.g. `import \"lol/foo\"` => 'lol/foo'\n//   file:SrcFile\n//   moduleID:AST.Identifier         // e.g. `import foo from \"lol/foo\"` => 'foo'\n//   members:[{asID: AST.Identifier, srcID:AST.Identifier}, ...]\n//      e.g. `import {Foo as bar} from \"foo\"` => {bar:'Foo'}\n//   node:ASTNode                    // the import node\n// }\nimport {repr, JSIdentifier, SrcError, SrcLocation} from '../util'\nimport {types as t} from 'npmjs.com/babel'\nvar __DEV__ = true; // FIXME remove when we build ourselves\n\nfunction ImportError(file, node, message, fixSuggestion, related) {\n  return SrcError('ImportError', SrcLocation(node, file), message, fixSuggestion, related);\n}\n\n\nvar implicitExportNameRe = /^[A-Z]/u;\n  // TODO: Add all upper-case Unicode letters to the regex, e.g. \\uXXXX-\\uXXXX ...\n\nfunction isImplicitExportName(name) {\n  return name.match(implicitExportNameRe) //&& (name[0] === name[0].toUpperCase());\n}\n\n\nvar ModuleTransformer = {\n\n  ImportDeclaration(node, parent, scope, file) {\n    if (node.isType) return;\n\n    if (node.range && node.range[0] > file.joFirstNonImportOffset) {\n      throw ImportError(file.jofile, node, 'unexpected import below non-import statement');\n    }\n\n    // Note: Imports are only at \"program\" level, enforced by the parser,\n    // so no need to check parent.type==='Program'.\n\n    if (node.source.value.substr(0,14) === 'babel-runtime/') {\n      //console.log('runtime-helper', repr(node,3));\n      node.jo_isRuntimeHelper = true;\n    } else {\n      if (node.specifiers.length) {\n        let hasDefault = false;\n        for (let i = 0, L = node.specifiers.length; i !== L; ++i) {\n          let spec = node.specifiers[i];\n          let origName;\n          if (spec.name) {\n            // x as y\n            origName = spec.name.name;\n            spec.name = file.joLocalizeIdentifier(spec.name.name)\n          } else {\n            origName = spec.id.name;\n            spec.id._origName = spec.id.name;\n            spec.name = file.joLocalizeIdentifier(spec.id.name)\n            // console.log('spec', repr(spec,3)); // path\n          }\n          spec.name._origName = origName; // because scope.rename() later on\n          if (spec.default) {\n            hasDefault = true;\n          }\n        }\n        // if (!hasDefault) {\n        //   console.log('!hasDefault', node.specifiers)\n        //   let anonID = file.joGenAnonID();\n        //   node.specifiers.splice(0,0, t.importSpecifier(anonID, null) );\n        //   // node.specifiers[0].default = true;\n        // }\n      } else {\n        // Shorthand `import \"bar/jo-foo.git\"` == `import foo from \"bar/jo-foo.git\"`\n        let name = JSIdentifier.fromString(node.source.value);\n        if (!name || !JSIdentifier.isValid(name)) {\n          throw ImportError(file.jofile, node.source, 'failed to infer module identifier');\n        }\n        \n        // Register binding as name (not yet localized) so that we later can correctly\n        // perform scope.rename\n        let spec = t.importSpecifier(null, t.identifier(name));\n        spec.default = true;\n        node.specifiers = [ spec ];\n        file.scope.registerBinding(\"module\", node);\n\n        // Localize id\n        let id = file.joLocalizeIdentifier(name);\n        spec = t.importSpecifier(null, id);\n        spec.default = true;\n        node.specifiers = [ spec ];\n      }\n    }\n\n    // Extract imports -- will eventually be hoisted to package header\n    file.joImports.push(node);\n    // try {\n    //   file.scope.registerBinding(\"module\", node);\n    // } catch (e) {\n    //   // Most likely duplicate\n    // }\n    return [];\n  },\n\n\n  VariableDeclaration(node, parent, scope, file) {\n    // Export UpperCase vars at the module level.\n    // At this point in transformations, const, let and class have been\n    // converted to var, so this catches all but function.\n    if (parent.type === 'Program') {\n      if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n        file.joFirstNonImportOffset = node.range[0];\n      }\n      var i, id, decls = node.declarations, exportDecls = [];\n      for (i = 0; i !== decls.length; ++i) {\n        id = decls[i].id;\n        if (isImplicitExportName(id.name)) {\n          // console.log('export var', repr(decls[i], 2))\n          file.joRegisterExport(id.name, decls[i].id, /*isImplicitExport=*/true);\n        }\n      }\n    }\n  },\n\n\n  FunctionDeclaration(node, parent, scope, file) {\n    // Export UpperCase functions at the module level.\n    if (parent.type === 'Program') {\n      if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n        file.joFirstNonImportOffset = node.range[0];\n      }\n      if (isImplicitExportName(node.id.name)) {\n        // console.log('export function', repr(node, 2))\n        file.joRegisterExport(node.id.name, node.id, /*isImplicitExport=*/true);\n      }\n    }\n  },\n\n\n  ExportDeclaration(node, parent, scope, file) {\n    // Note: Always at program-level.\n\n    // Note: we don't see export statements until they have been processed by\n    // some other part of Babel, which hoists them to the top, meaning that\n    // if we set file.joHasPassedImports=true here, it will be set _before_\n    // the first line. I.e. in this program:\n    //   import 'a'\n    //   export function f() {}\n    // Babel will rewrite the AST to:\n    //   export {f as f}\n    //   import 'a'\n    //   function f() {}\n    // Meaning we will visit `export {f as f}` before we visit `import 'a'`.\n\n    if (node.range && node.range[0] < file.joFirstNonImportOffset) {\n      file.joFirstNonImportOffset = node.range[0];\n    }\n\n    if (node.declaration) {\n      if (node.default) {\n        // export default ...\n        file.joRegisterExport('default', node.declaration);\n      } else {\n        if (__DEV__) { t.assertVariableDeclaration(node.declaration); }\n        let decl = node.declaration.declarations[0];\n        if (__DEV__) { t.assertVariableDeclarator(decl); }\n        file.joRegisterExport(decl.id.name, decl.id);\n        return node.declaration;\n      }\n    } else {\n      // node.specifiers:ExportSpecifier[]\n      // console.log('export', repr(node, 3))\n      node.specifiers.forEach((spec) => {\n        file.joRegisterExport(spec.name ? spec.name.name : spec.id.name, spec.id);\n      })\n    }\n    return [];\n  },\n\n\n  // post(file) {\n  //   // Append export statements to the end.\n  //   if (file.joIsLastFile) {\n  //     //file.ast.program.body\n  //     console.log(repr(file.ast));\n  //   }\n  // }\n\n}\n","import {SrcLocation, SrcError} from '../util'\nimport {types as t} from 'npmjs.com/babel'\n\n\nfunction ReferenceError(file, node, message, related) {\n  return SrcError('ReferenceError', SrcLocation(node, file), message, null, related);\n}\n\n\nvar FileLocalVarsTransformer = {\n\n  IfStatement(node, parent, scope, file) {\n    var test = node.test;\n    if (test.type === 'Identifier' && test.name === '__DEV__' && !scope.getBindingInfo(test.name)) {\n      if (node.consequent.type === 'BlockStatement' && !node.consequent._letReferences) {\n        return node.consequent.body;\n      }\n      return node.consequent;\n    }\n  },\n\n  Identifier(node, parent, scope, file) {\n    if (node.name === '__DEV__' && !scope.getBindingInfo(node.name)) {\n      return t.literal(file.joTarget.isDevMode);\n    }\n  },\n\n  FunctionDeclaration(node, parent, scope, file) {\n    if (node.id &&\n        node.id.type === 'Identifier' &&\n        node.id.name === 'init' &&\n        parent.type === 'Program')\n    {\n      node.id = file.joLocalizeIdentifier(node.id.name);\n      file.jofile.initFuncName = node.id.name;\n    }\n  },\n\n  // ObjectExpression(node, parent, scope, file) {\n  //   if (file.jofile.name === 'primate.js') {\n  //     console.log('ObjectExpression:', repr(node,0))\n  //   }\n  // },\n\n  post(file) {\n    // Rename remapped identifiers in this file\n    Object.keys(file.joRemappedIdentifiers).forEach((oldName) => {\n      let newName = file.joRemappedIdentifiers[oldName];\n      //assert(file.scope.getBindingInfo(oldName) != undefined);\n      file.scope.rename(oldName, newName);\n    });\n\n    // dumpScopeBindings(file.scope);\n\n    var undefinedSymbolResolvers = {\n\n      React: (node, parent, scope) => {\n        // Add `import React from \"react\"`\n        file.joAddImplicitImport('react', {'default':'React'}, node);\n        return true;\n      },\n\n      ReactComponent: (node, parent, scope) => {\n        // Add `import {Component as ReactComponent} from \"react\"`\n        file.joAddImplicitImport('react', {'Component':'ReactComponent'}, node);\n        return true;\n      },\n\n    };\n\n    // Attempt to automatically resolve any undefined references, like \"React\".\n    var verifyReference = (name, node, parent, scope, isNewName:bool) => {\n      if (!(node.name in file.joTarget.globals)) {\n        var info = scope.getBindingInfo(node.name);\n        if (!info) {\n          let resolver = undefinedSymbolResolvers[node.name];\n          if (!resolver || !resolver(node, parent, scope)) {\n            if (!file.jofile.unresolvedIDs) { file.jofile.unresolvedIDs = {}; }\n            if (!file.jofile.unresolvedIDs[node.name]) {\n              file.jofile.unresolvedIDs[node.name] = {node:node};\n            }\n            if (file.jofile.superclassReferences) {\n              let superclassRef = file.jofile.superclassReferences[node.name];\n              if (superclassRef) {\n                if (!file.jofile.unresolvedSuperclassIDs) {\n                  file.jofile.unresolvedSuperclassIDs = {};\n                }\n                file.jofile.unresolvedSuperclassIDs[node.name] = superclassRef;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    file.scope.traverse(file.scope.block, {\n      enter: function enter(node, parent, scope) {\n        if (parent.type === 'BreakStatement') {\n          // BUG: Can't handle \"break to label\" reference checks. This means that\n          //      \"break foo;\" will not generate any errors, even when there's no\n          //      label called \"foo\".\n          return;\n        }\n        if (t.isReferencedIdentifier(node, parent)) {\n          verifyReference(node.name, node, parent, scope);\n        }\n      }\n    });\n\n    // Special code for \"exports default { ... }\"\n    if (file.joPkg.exports['default']) {\n      file.scope.traverse(file.joPkg.exports['default'].node, {\n        enter: function enter(node, parent, scope) {\n          if (t.isReferencedIdentifier(node, parent)) {\n            let name = node.name;\n            if (!(name in file.joTarget.globals) && !(name in file.scope.globals)) {\n              var info = scope.getBindingInfo(name);\n              if (!info) {\n                let remapped = file.joRemappedIdentifiers[name];\n                if (remapped) {\n                  node.name = remapped;\n                }\n              }\n            }\n          }\n        }\n      });\n    }\n\n    // A map of any identifiers defined at the program-level of this file\n    // console.log('file.scope.bindings:', repr(file.scope.bindings,2));\n    Object.keys(file.scope.bindings).forEach(name => {\n      var binding = file.scope.bindings[name];\n      if (binding &&\n          (binding.kind === 'var' ||\n           binding.kind === 'let' ||\n           binding.kind === 'const' ||\n           binding.kind === 'hoisted') )\n      {\n\n        if (!file.jofile.definedIDs) {\n          file.jofile.definedIDs = {};\n        }\n        if (!file.jofile.definedIDs[name]) {\n          file.jofile.definedIDs[name] = binding;\n        }\n\n        // Check for duplicate ID\n        if (!file.joPkg.definedIDs) {\n          file.joPkg.definedIDs = {};\n        } else if(file.joPkg.definedIDs[name]) {\n          let existingDecl = file.joPkg.definedIDs[name];\n\n          let bindingKind = binding.kind;\n          let otherBindingKind = existingDecl.binding.kind;\n          let node = binding.node;\n          let otherNode = existingDecl.binding.node;\n\n          if (bindingKind === 'hoisted') {\n            bindingKind = 'function';\n            node = node.id;\n          }\n\n          if (otherBindingKind === 'hoisted') {\n            otherBindingKind = 'function';\n            otherNode = otherNode.id;\n          }\n\n          throw ReferenceError(\n            file.jofile,\n            node,\n            `duplicate identifier in ${bindingKind} declaration`,\n            [{ message: `${otherBindingKind} declared here`,\n              srcloc: SrcLocation(otherNode, existingDecl.file)\n            }]\n          );\n        }\n\n        // Register ID\n        file.joPkg.definedIDs[name] = {binding:binding, file:file.jofile};\n        \n        // Is main() function?\n        if (name === 'main' && binding.node.type === 'FunctionDeclaration') {\n          // Note: as main is included in definedIDs we already check for duplicate declarations,\n          // so no need to check for duplicate mainFunc here.\n          file.joPkg.mainFunc = {node: binding.node, file: file.jofile};\n        }\n\n      } //else console.log('other binding', binding ? binding.kind : binding);\n    });\n  }\n\n}\n\n\n// function dumpScopeBindings(scope, depth=0) {\n//   let indent =\n//     '                                                                      '.substr(0,depth*4);\n//   for (var k in scope.bindings) {\n//     console.log(indent+k, '=>', repr(scope.bindings[k],0));\n//   }\n//   if (depth !== -1 && scope.parent) {\n//     console.log(indent+'.parent:');\n//     dumpScopeBindings(scope.parent, depth+1);\n//   }\n// }\n","var ClassHierarchyTransformer = {\n\n  ClassDeclaration(node, parent, scope, file) {\n    if (!file.jofile.classDeclaration) { file.jofile.classDeclaration = {}; }\n    file.jofile.classDeclaration[node.id.name] = node.superClass || null;\n\n    if (node.superClass) {\n      // console.log('class', node.id.name, 'extends', node.superClass.name);\n      if (!file.jofile.superclassReferences) { file.jofile.superclassReferences = {}; }\n      file.jofile.superclassReferences[node.superClass.name] = node;\n    }\n  }\n\n}\n"]}